<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head><title>Flexible Box Layout Module</title>
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-ED"> <!-- TODO: remove before build -->
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-[STATUS]">
  <link rel="stylesheet" type="text/css" href="../default.css">
<style type="text/css">
.style1 {
	background-color: #FFFF00;
}
</style>
</head><body>

<div class="head">
	<h1 id="head-box-flexible">Flexible Box Layout Module</h1>
	<h2 class="no-num no-toc" id="w3c-working">[LONGSTATUS], [DATE]</h2>

	<dl>
		<dt>This version:
			<dd><!-- <a href="http://www.w3.org/TR/[YEAR]/WD-[SHORTNAME]-[CDATE]/">http://www.w3.org/TR/[YEAR]/WD-[SHORTNAME]-[CDATE]/</a></dd> -->
				<a href="http://dev.w3.org/csswg/[SHORTNAME]/">http://dev.w3.org/csswg/[SHORTNAME]/</a>

		<dt>Latest version:
			<dd><a href="http://www.w3.org/TR/css3-flexbox/">http://www.w3.org/TR/css3-flexbox/</a>

		<dt>Editors:
			<dd>Tab Atkins Jr. <a href="mailto:jackalmage@gmail.com">jackalmage@gmail.com</a>
			<dd>Alex Mogilevsky <a href="mailto:alexmog@microsoft.com">alexmog@microsoft.com</a>
			<dd>L. David Baron, Mozilla Corporation, <a href="mailto:dbaron@dbaron.org">dbaron@dbaron.org</a>

		<dt>Authors and former editors:
			<dd>Neil Deakin, Mozilla Corporation, <a href="mailto:enndeakin@gmail.com">enndeakin@gmail.com</a>
			<dd>Ian Hickson, formerly of Opera Software, <a href="mailto:ian@hixie.ch">ian@hixie.ch</a>
			<dd>David Hyatt, Apple, <a href="mailto:hyatt@apple.com">hyatt@apple.com</a>
	</dl>
	<!--copyright-->
</div>

<hr>

<div>
	<h2 class="no-num no-toc" id="abstract">Abstract</h2>

	<p>The draft describes a CSS box model optimized for interface design.
	It provides an additional layout system alongside the ones already in
	CSS.  [[!CSS21]]  In this new box model, the children of a box are
	laid out either horizontally or vertically, and unused space can be
	assigned to a particular child or distributed among the children by
	assignment of "flex" to the children that should expand.
	Nesting of these boxes (horizontal inside vertical, or vertical inside
	horizontal) can be used to build layouts in two dimensions.  This
	model is based on the box model in the XUL user-interface language
	used for the user interface of many Mozilla-based applications
	(such as Firefox).</p>
</div>

<div>
	<h2 class="no-num no-toc" id="table">Table of contents</h2>
	<!--toc-->
</div>

<hr>

<div>
	<h2 id="overview">Overview</h2>

	<p>CSS 2.1 defined three layout modes, algorithms which determine the size and 
	position of boxes based on their relationships with their sibling and ancestor 
	boxes: normal layout, designed for laying out documents and simple applications,
	table layout, designed for laying out information in a tabular format, and 
	positioned layout, designed for very explicit positioning without much regard 
	for other elements in the document. This module introduces a new layout mode, 
	flexbox layout, which is designed for laying out more complex applications and 
	webpages.</p>

	<p>In CSS, flexboxes may be created by setting the 'display' property. A block-level 
	flexbox can be specified with a value of ''flexbox'' and an inline flexbox can be 
	specified using a value of ''inline-flexbox''.  A block-level flexbox placed inside
	a block level element is positioned and sized as if it were any other block. 
	An inline-level flexbox placed inside another element is positioned and sized 
	like an inline-block.</p>

	<p class=issue>It's expected that the 'display' property will be split into 
	'display-inside' and 'display-outside' subproperties to specify, respectively,
	how elements layout themselves and their children, and how they are laid out by
	their parents.  Once this happens, we can cut this down to merely
	''display-inside:flexbox'', and let people set 'display-outside' to ''block'' or
	''inline'' as they wish, or even ''table-cell''.</p>

	<p>Inline children of a flexbox are wrapped in anonymous blocks. All other children
	are block-level.  These anonymous blocks or block-level boxes are referred to as
	''flexbox children'' in this specification.</p>

	<p>Flexbox children may specify their width and height using the 'width' and 
	'height' properties. The width and height of replaced elements is computed as with
	replaced elements in inline contexts. Otherwise, if the width is set to ''auto'', then the
	used value is the intrinsic size, which may be calculated using a shrink-to-fit algorithm,
	as with inline-block elements, i.e., it will be given the minimum amount of space required
	to lay out the element without unnecessary line breaks. Similarly, if the height is set to
	''auto'', then the used value in a similar manner.</p>

	<p>An unnested flexbox placed inside an enclosing block will obey all the
	usual sizing rules of the block. For example, setting the width of an unnested flexbox to
	100% ensures that the flexbox is the maximum width permitted by the enclosing block
	(ignoring any margins, border and padding on that box).</p>

	<p>The difference between flexboxes and blocks is in how the children of the
	element are laid out. Flexbox children are all block-level (inline-level
	contents get wrapped in anonymous blocks).
	These blocks then get stacked in the direction specified by the 'flex-direction'
	property and order specified by the 'flex-order' property.  They are aligned
	within the box according to their margins and the 'flex-align' property.  The 
	flexbox children may then flex or be distributed as specified by their margins,
	the 'flex' property, and the 'flex-pack' property.</p>
	</p><p>

	<p>The 'float' and 'clear' properties do not apply to flexbox children, so the
	used value of these properties is ''none''.  Similarly, none of the properties 
	defined in the CSS Multicol module apply to flexboxes or flexbox children, so 
	the used value of all such properties is the initial value.</p>

	<div class="example">
		<p>For example:</p>

		<pre class=html>
&lt;p style="width: 400px; display: flexbox;">
	&lt;button style="width: 200px;">Child 1&lt;/button>
	&lt;button style="width: 100px;">Child 2&lt;/button>
&lt;/p>
		</pre>

		<p>In this example, the first button is 200 pixels wide and the second button is
		100 pixels wide. As the flexbox is 400 pixels wide, there is extra space left over
		which is placed after the two buttons but inside the flexbox. The placement of this
		extra space may be modified using the various flex properties described in the next
		sections. Neither the height of the buttons nor the height of the flexbox are specified,
		so the height is computed intrinsically from the content. In this case, the buttons
		will be the height needed to display the label and button border, and the flexbox will
		also be this height plus any margins around the buttons.</p>
	</div>

	<p>Elements within a box may use the 'overflow' property
	to control whether a scrolling mechanism appears when the children of a box overflow.
	A scrolling mechanism may be displayed when flexible elements are reduced below their minimum
	intrinsic size when the overflow property is set to ''auto'' or ''scroll''.
	If 'overflow' is ''hidden'', the element will be clipped instead. <em>Note
	that the initial value is ''visible'', which is
	typically not the preferred effect in user interfaces.</em></p>
</div>

<!-- ====================================================================== -->

<div>
	<h2 id=display-flexbox>New values for 'display' property</h2>

	<table class="propdef">
		<tbody>
			<tr>
				<th>Name:
				<td>display
			<tr>
				<th>New value:
				<td>flexbox
		</tbody>
	</table>

	<p>You can declare that an element is a flexbox, and thus should use flexbox 
	layout, by setting the 'display' property on the element to the value 
	''flexbox''.</p>

	<p>All children of a flexbox must be block-level or atomic inline-level 
	elements.  Contiguous runs of non-replaced inline elements are wrapped in an 
	anonymous block-level box.  Out-of-flow elements (such as absolutely 
	positioned elements - floats are also out-of-flow but can't exist as flexbox 
    children) leave behind a "placeholder" in their original source 
	location which is treated like a non-replaced inline element for the purpose of 
	this wrapping.  (This can, for example, create an empty flexbox child, if all 
	the children are block-level elements and one is absolutely positioned.)  It is 
	recommended that authors avoid putting in elements which are auto-wrapped with 
	anonymous boxes, as the anonymous boxes cannot be targetted and controlled with 
	the various flexbox properties defined in later sections.</p>

	<p>A flexbox child creates a new BFC.  The margins of a flexbox child 
	do not collapse with any other margin.</p>

	<p>Setting ''display:flexbox'' on an element forces it to use a new layout 
	algorithm, and so some properties that were designed with the assumption of 
	"normal" flow don't make sense in a flexbox context.  In particular:</p>

	<ul>
		<li>all of the 'column-*' properties in the Multicol module compute to their initial 
		values on a flexbox ('break-before', 'break-inside', and 'break-after' are still 
		valid on a flexbox).</li>
		<li>'float' and 'clear' compute to their initial values on a flexbox child</li>
		<li class=issue>[Others?]</li>
	</ul>
</div>

<!-- ====================================================================== -->

<div>
	<h2 id=flex-direction>Flexbox Direction: the 'flex-direction' property</h2>

	<table class=propdef>
		<tbody>
			<tr>
				<th>Name:
				<td><dfn>flex-direction</dfn>
			<tr>
				<th>Values:
				<td>lr | rl | tb | bt | inline | inline-reverse | block | block-reverse
			<tr>
				<th>Initial:
				<td>inline
			<tr>
				<th>Applies To:
				<td>Flexboxes
			<tr>
				<th>Inherited:
				<td>No
			<tr>
				<th>Computed Value:
				<td>See text
			<tr>
				<th>Media:
				<td>visual
		</tbody>
	</table>

	<p>The 'flexbox-direction' property specifies how flexbox children 
	are placed on each line of the flexbox.  A value of ''lr'' means that 
	the first flexbox child is placed against the left edge of the flexbox, with 
	later children placed immediately to the right of the preceding flexbox child.  
	A value of ''rl'' is the same, but with the initial flexbox child 
	placed against the right edge of the flexbox and later children placed to the 
	left.  Both of these values mean that the flexbox is a <dfn>horizontal 
	flexbox</dfn>.  A value of ''tb'' means that the first flexbox 
	child is placed against the top edge of the flexbox, with later children placed 
	immediately below it, while ''bt'' means the first child is placed 
	against the bottom edge of the flexbox, with later children placed immediately 
	above it.  Both of these values mean that the flexbox is a <dfn>vertical 
	flexbox</dfn>.</p>

	<p>A value of ''inline'' computes to one of ''lr'', ''rl'', ''tb'', or ''bt'', 
	depending on the direction and block-flow of the flexbox: if the start side of
	the flexbox is the left side, ''inline'' must compute to ''lr''; similarly, if
	the start side of the flexbox is the right, top, or bottom side, ''inline''
	must compute to ''rl'', ''tb'', or ''bt'' respectively.  ''inline-reverse'',
	''block'', and ''block-reverse'' determine their computed value identically to
	''inline'', but use the location of the end side, before side, and after side
	of the flexbox, respectively.</p>

	<div class=example>
		<p>A vertical flexbox can be used to emulate the functionality of HTML's
		''&lt;center>'' element:</p>
		<pre>
&lt;div>
	&lt;span>foo foo foo foo&lt;/span>
	&lt;span>bar bar&lt;br>bar bar&lt;/span>
	&lt;span>foo foo foo foo foo foo foo foo foo foo foo foo&lt;/span>
&lt;/div>
&lt;style>
	div {
		display: flexbox;
		flex-direction: tb;
		width: 200px;
	}
	span {
		margin: 0 auto;
	}
&lt;/style>
		</pre>
		<p><img alt="" src="images/basic-vertical-flexbox.png"></p>
	</div>

	<p>In the rest of this specification, the direction in which new flexbox children
	are laid out will be referred to as the <dfn>layout direction</dfn> (if a
	precise direction is required) or the <dfn>layout axis</dfn> (if only the axis
	orientiation is required).</p>

	<p>The axis perpendicular to the ''layout axis'' will be refered to as the
	<dfn>transverse axis</dfn>, with the <dfn>transverse direction</dfn> being
	either a line extending from the ''before'' side of the flexbox to the ''after''
	side, or from the ''start'' side of the flexbox to the ''end'' side, whichever
	would produce a direction parallel to the ''transverse axis''.</p>
</div>

<!-- ====================================================================== -->

<div>
	<h2 id=flex-order>Display Order: the 'flex-order' property</h2>

	<p>Flexbox children are, by default, displayed and laid out in the same order
	as they appear in the source document.  The 'flex-order' property may be used
	to change this ordering.</p>

	<table class=propdef>
		<tr>
			<th>Name:
			<td>flex-order
		<tr>
			<th>Value:
			<td>&lt;integer>
		<tr>
			<th>Initial:
			<td>1
		<tr>
			<th>Applies to:
			<td>''flexbox children''</td>
		<tr>
			<th>Inherited:
			<td>No
		<tr>
			<th>Computed value:
			<td>specified value
		<tr>
			<th>Media:
			<td>visual
	</table>

	<p class=issue>Maybe name this 'flex-index' instead, to be consistent with 'z-index'.</p>

	<p>Flexbox children may be assigned to ''ordinal groups'' using the 'flex-order'
	property.  This property is an integer with an initial value of 1.</p>

	<p>Ordinal groups control the order in which flexbox children appear.  A flexbox
	will lay out its children starting from the lowest numbered ordinal group and
	going up.  Elements with the same ordinal group are laid out in the order they
	appear in the source document.

	<div class=example>
		<p>This example shows how ordinal groups might be used.</p>
		<pre><code>	div { display: flexbox; }
	#span1 { flex-order: 2; }
	#span3 { flex-order: 2; }
	#span4 { flex-order: 1; }

	&lt;div>
		&lt;span id="span1">span1&lt;/span>
		&lt;span id="span2">span2&lt;/span>
		&lt;span id="span3">span3&lt;/span>
		&lt;span id="span4">span4&lt;/span>
	&lt;/div></code></pre>

		<p>The first ordinal group, 1, contains span2 and span4. As span2 does not 
		specify an ordinal group, it will default to 1. The elements will be displayed 
		in document order, so span2 will be displayed before span4. The second ordinal 
		group, 2, contains the remaining two spans. The resulting display order will 
		be:</p>

		<pre><code>span2 span4 span1 span3</code></pre>
	</div>
</div>

<!-- ====================================================================== -->

<div>
	<h2 id=flex>Flexibility: the 'flex' property</h2>
	
	<p>Each flexbox child may be made either ''flexible'' or ''inflexible''.  Flexible
	elements may grow when the flexbox has extra space available after the size of
	all the flexbox children have been computed, or shrink if the combined size
	of all the flexbox children would cause the flexbox to overflow.  Inflexible
	elements do not change size, even when there it too much or too little space
	left over in the flexbox.</p>

	<p>The flexibility defined in this section only affects the size of flexbox child
	in the ''layout axis''. (That is, it only affects the width of a flexbox child
	in a horizontal flexbox, or the height in a vertical flexbox.)</p>

	<table class=propdef>
		<tr>
			<th>Name:
			<td>flex-grow
		<tr>
			<th>Value:
			<td>&lt;number>
		<tr>
			<th>Initial:
			<td>0.0
		<tr>
			<th>Applies to:
			<td>flexbox children
		<tr>
			<th>Inherited:
			<td>no
		<tr>
			<th>Computed Value:
			<td>specified value
		<tr>
			<th>Media:
			<td>visual
	</table>

	<table class=propdef>
		<tr>
			<th>Name:
			<td>flex-shrink
		<tr>
			<th>Value:
			<td>&lt;number>
		<tr>
			<th>Initial:
			<td>0.0
		<tr>
			<th>Applies to:
			<td>flexbox children
		<tr>
			<th>Inherited:
			<td>no
		<tr>
			<th>Computed Value:
			<td>specified value
		<tr>
			<th>Media:
			<td>visual
	</table>

	<p>An element is <dfn>flexible</dfn> when the 'flex-grow' or 'flex-shrink' property is 
	non-zero.  These properties are floating point values representing the flexibility
	of the flexbox child when the flexbox children are too small or too large, respectively,
	for the flexbox.  When there is extra space left over in a flexbox, the flexible
	elements with a non-zero 'flex-grow' are expanded to fill that space.  When a
	flexbox's contents would overflow the flexbox, the flexible elements with a 
	non-zero 'flex-shrink' are shrunk to keep the contents from overflowing.</p>

	<p>All flexibility is relative.  For example, a flexbox child with a 'flex-grow'
	of 2 is twice as flexible (and thus will absorb twice as much free space) as
	a flexbox child with a 'flex-grow' of 1.</p>

	<p>Both 'flex-grow' and 'flex-shrink' must be non-negative.  A negative value
	for either property is a syntax error.</p>

	<p>The precise details of how flexibility is treated are defined in a later
	section of this specification.  Generally, flexbox children compute their 
	''preferred size'' in the ''layout axis'', which is then summed between all 
	the flexbox children	and subtracted from the size of the flexbox in the 
	''layout axis''.  If the resultant value is positive, there is free space left
	over, and it is apportioned out to each flexbox child relative to their 'flex-grow'
	value, so that their actual size is their preferred size plus their portion
	of the free space.  If the resultant value is negative, the flexbox's contents
	would overflow, and so each flexbox child has its size reduced relative to its
	'flex-shrink' value so that the flexbox's contents fit in the flexbox without
	overflowing.</p>
	<!--
If the size in the layout axis is computed first, then 'auto' resolves as 'fit-content'.
Do the flexing calculations, set real size, then calculate the size in the transverse
axis using this size.  Do flexing calcs in the transverse axis.

If the size in the layout axis is computed second, then resolve the size in the 
transverse axis as 'fit-content', and using this, determine the size in the layout
axis.  Do the flexing calculations, set real size.  Continue using the same value
previously determined to do flexing in the transverse axis.
-->

<!-- ====================================================================== -->

<div>
	<h2 id=flex-align>Alignment: the 'flex-align' property</h2>

	<p>When the size of the flexbox is larger than the size of a child, extra space
	will be available.  The 'margin' and 'flex-align' properties specify how a 
	flexbox's children are placed and aligned along the ''transverse axis'', and
	where the extra space, if any, is positioned.</p>

	<p>The amount of extra space may be different for each flexbox child.  For 
	example, if a horizontal flexbox has a height of 200px and contains two children
	at heights of 100px and 150px, there will be 100px of extra space for the first
	child and 50px of extra space for the second child.</p>

	<table class=propdef>
		<tr>
			<th>Name:
			<td>flex-align
		<tr>
			<th>Value:
			<td>shrink | before | middle | after | baseline
		<tr>
			<th>Initial:
			<td>shrink
		<tr>
			<th>Applies to:
			<td>flexbox children
		<tr>
			<th>Inherited:
			<td>no
		<tr>
			<th>Computed Value:
			<td>specified value
		<tr>
			<th>Media:
			<td>visual
	</table>

	<p>The 'flex-align' property specifies how a flexbox child's contents are aligned,
	by flexing the box's padding.  Like table cells, the contents of a flexbox child can be aligned
	independently within the flexbox child.  The property also affects how auto
	height or widths on the flexbox child are resolved.</p>

	<p class=note>The following contents of this section are completely informative.
	The effects of this property are normatively defined in the Free Space Distribution
	section later in this spec.</p>

	<p>Flexbox children always determine their size in the ''transverse axis'' by
	using the shrink-to-fit algorithm.  Flex-align</p>

	<p>If the flexbox child's inline-progression axis (that is, the axis connecting the
	start and end sides of the box) is the same as the flexbox's ''transverse axis''
	(for example, if the flexbox child contains normal English text and the flexbox
	is vertical), this property has no effect on the alignment of the flexbox child's contents.
	They must be laid out as normal for their layout mode, which is normal block 
	layout by default.  This property will still affect how auto heights or widths 
	are resolved.</p>

	<p>Otherwise, the contents of a flexbox child are aligned as described in the
	following paragraphs.  For clarity, the algorithms described below will assume
	a horizontal flexbox and flexbox children with a horizontal writing mode.  With
	this assumption, the terms "top", "bottom", and "height" will be used, with 
	the understanding that "top" refers to the edge or direction of the flexbox 
	in the ''transverse axis'' that children are first aligned to, "bottom" refers 
	to the opposite side or direction, and "height" refers to the size of the relevant
	box in the ''transverse'' axis.  The algorithms are trivially applicable to 
	vertical flexboxes and flexbox children with vertical writing modes as well.  
	<span class=note> (These algorithms don't apply to vertical-writing-mode flexbox 
	children of horizontal flexboxes or horizontal-writing-mode flexbox children 
	of vertical flexboxes, as specified in the previous paragraph.)</p>

	<dl>
		<dt>''before'' and ''shrink''
		<dd>The flexbox child aligns its content's top edge to its top inner 
		edge.

		<dt>''after''
		<dd>The flexbox child aligns its content's bottom edge to its bottom
		inner edge.

		<dt>''middle''
		<dd>The middle of the flexbox child's contents (the point halfway between 
		the top and bottom of the content) is aligned to the middle of the 
		flexbox (the point halfway between the top and bottom inner edges of the
		flexbox).

		<dt>''baseline''
		<dd>The flexbox child with the largest distance between its top outer edge
		and its baseline must have its content's top edge aligned to its top inner 
		edge.  All other flexbox children with this value must have additional space
		inserted between their padding edge and their inner edge to make
		their baselines align with that of the aforementioned flexbox child.
	</dl>

	<p>To avoid ambiguous situations, the alignment of flexbox children proceeds
	in the following order:</p>

	<ol>
		<li>Align the flexbox children with ''flex-align:baseline''.  This will
		establish the baseline of the flexbox.
		<li>Align the flexbox children with ''flex-align:before'' or 
		''flex-align:shrink''.
		<li>The flexbox now has a top, possibly a baseline, and a ''provisional 
		height'', which is the distance from the top inner edge of the flexbox to 
		the farthest bottom outer edge of the flexbox children positioned so far.
		<li>If any of the remaining cells have an outer height that is larger than the
		''provisional height''
		

	<p>If a child's margins along the ''transverse axis'' are ''auto'', they will
	grow to absorb the extra space.  If one margin is ''auto'', it is set to the
	amount of extra space in the ''transverse axis''; if both are ''auto'', each are
	set to half the amount of extra space.</p>



<h2>Flexibility</h2>

<P>The defining aspect of Flexbox Layout is <EM>flexibility</EM> - flexbox 
children can be made <STRONG>flexible</STRONG>, which means they'll work 
together to distribute available space, stretching or shrinking their widths and 
heights as necessary to fill the flexbox completely.  The space around and 
between the children can flex as well, pushing the children around inside the 
flexbox.</P>
<P>This is controlled through several new properties, and some existing 
properties: the width/height properties, <CODE>flex-stretch</CODE> controls the 
size of the flexbox children in the direction of the flexbox (width for 
horizontal flexboxes, height for vertical flexboxes), <CODE>margin</CODE> and 
<CODE>flex-pack</CODE> control the space between flexbox children in the 
direction of the flexbox, and <CODE>margin</CODE>, the width/height properties, 
and <CODE>flex-align</CODE> control the size, spacing, and alignment of boxes in 
the perpendicular direction.</P>
<P>Note: The flexbox properties in this section are symmetrical for horizontal 
and vertical flexboxes, except where noted.  To simplify the language, this 
section will assume a horizontal flexbox.  In a vertical flexbox all properties 
apply in the same way, with all references to physical directions or dimensions 
swapped to the relevant direction or dimension in the opposite direction.</P>
<P><STRONG>This chapter is almost entirely informative.  The only normative 
content in this chapter, and the contained subchapters, are the syntax 
definitions of the properties introduced herein.  In particular, the 
descriptions of how these properties work <EM>are entirely informative</EM>.  A 
later section of the spec gives the normative meaning of each property, in terms 
of the sizing algorithm.</STRONG></P>
<DL>
  <DT>new property</DT>
  <DD><CODE><span class="style1">flex-grow</span></CODE></DD>
  <DT>values</DT>
  <DD><CODE>&lt;number&gt;</CODE></DD>
  <DT>default value</DT>
  <DD><CODE>0.0</CODE></DD>
  <DT>allowed on</DT>
  <DD>flexbox children</DD>
  <DT>new property</DT>
  <DD><CODE><span class="style1">flex-shrink</span></CODE></DD>
  <DT>values</DT>
  <DD><CODE>&lt;number&gt;</CODE></DD>
  <DT>default value</DT>
  <DD><CODE>0.0</CODE></DD>
  <DT>allowed on</DT>
  <DD>flexbox children</DD>
  <DT>new property</DT>
  <DD><CODE><span class="style1">flex-stretch</span></CODE></DD>
  <DT>values</DT>
  <DD><CODE>&lt;flex-grow&gt; &lt;flex-shrink&gt;</CODE></DD>
  <DT>default value</DT>
  <DD><CODE>0.0 0.0</CODE></DD>
  <DT>allowed on</DT>
  <DD>flexbox children</DD></DL>
<P>The <CODE>flex-grow</CODE> and <CODE>flex-shrink</CODE> properties control 
whether or not a flexbox child's width is flexible, and how flexible it is.  The 
value of these properties must be non-negative numbers; a negative number for 
either value renders the property invalid.  The <CODE>flex-stretch</CODE> 
property is a shorthand property which sets both <CODE>flex-grow</CODE> and 
<CODE>flex-shrink</CODE> together.</P>
<P>Free space is determined by subtracting the sum of the <STRONG>preferred 
widths</STRONG> of the flexbox children from the width of the flexbox.  The free 
space may be positive, in which case any flexible children may grow to fill the 
space, or negative, in which case any flexible children may shrink to avoid 
overflowing the space, in either case respecting min and max widths on the 
flexbox children as well.  The <STRONG>preferred width</STRONG> of a flexbox 
child with a specified width is that width; otherwise, it's the max-content 
width of the flexbox child.</P>
<P>If there is positive free space in the flexbox, then any flexbox child with a 
non-0 value for flex-grow is considered <STRONG>flexible</STRONG>.  Flexible 
children will divide up the free space proportionally according to their 
<CODE>flex-grow</CODE> values.  For example, if the flexbox has three children, 
two with <CODE>flex-grow:1</CODE> and one with <CODE>flex-grow:2</CODE>, and 
there is 100px of free space in the flexbox, the first two children will 
increase their width by 25px, while the latter child will increase its width by 
50px.</P>
<P>Similarly, if there is negative free space in the flexbox, then any flexbox 
child with a non-0 value for flex-shrink is considered 
<STRONG>flexible</STRONG>.  Flexible children will divide up the (negative) free 
space proportionally according to their <CODE>flex-shrink</CODE> values.  For 
example, if the flexbox has three children, two with <CODE>flex-shrink:1</CODE> 
and one with <CODE>flex-shrink:2</CODE>, and there is -100px of free space in 
the flexbox, the first two children will decrease their width by 25px, while the 
latter child will decrease its width by 50px.</P>
<P>Auto left and right margins also participate in free space distribution, 
similar to if they were blocks with <CODE>width:0; flex-grow:1;</CODE>.</P>


<h2>Packing along the box axis (<span class="issue">new</span>)</h2>
<DL>
  <DT>new property</DT>
  <DD><CODE>flex-pack</CODE></DD>
  <DT>values</DT>
  <DD><CODE>start | end | center | justify</CODE></DD>
  <DT>default value</DT>
  <DD><CODE>start</CODE></DD>
  <DT>applies to</DT>
  <DD>flexboxes</DD></DL>
<P>The <CODE>flex-pack</CODE> property specifies what to do with leftover free 
space if there are no flexible widths or margins, or if all flexible widths have 
grown to their maximum size and there is still space left over.</P>
<P>The <CODE>start</CODE> value specifies that flexbox children will be packed 
toward the start of the flexbox (this is not necessarily the 'start' logical 
edge - it's the edge of the flexbox that flexbox children are first placed 
against).  That is, any leftover free space must be placed at the end of the 
flexbox.</P>
<P>Similarly, the <CODE>end</CODE> value specifies that flexbox children will be 
packed toward the end of the flexbox (same caveat as above applies).  That is, 
leftover free space is placed at the start of the flexbox.</P>
<P>The <CODE>center</CODE> value specifies that flexbox children will be placed 
in the center of the flexbox; leftover free space is split equally between being 
placed at the start and end of the flexbox.</P>
<P>The <CODE>justify</CODE> value specifies that flexbox children will be spaced 
evenly in the flexbox; if there are N flexbox children, leftover free space is 
split into N-1 equal parts and inserted between each flexbox child.  There is no 
free space placed at the start or the end of the flexbox; the first and last 
flexbox child will be flush with the edges of the flexbox.</P>


<H2>Alignment (<span class="issue">new</span>)</H2>
<P>Vertically sizing and positioning flexbox children is much simpler than doing 
so horizontally, as you only have to worry about one box and its margins.  Free 
space is just the height of the flexbox minus the preferred height of the 
flexbox child and its top and bottom margins.  Ordinarily, an auto height will 
attempt to fill all the available space (<CODE>flex-align</CODE> can change this 
behavior, see below).  If there is space left over after computing the height, 
remaining space is split evenly between the auto margins.  If there is free 
space left over and neither margin is auto, then the free space is placed after 
the flexbox (the 'end' or 'after' logical side of the flexbox, whichever maps to 
a vertical direction).</P>
<DL>
  <DT>new property</DT>
  <DD><CODE>flex-align</CODE></DD>
  <DT>values</DT>
  <DD><CODE>shrink | before | after | middle | baseline</CODE></DD>
  <DT>default value</DT>
  <DD><CODE>before</CODE></DD>
  <DT>applies to</DT>
  <DD>flexbox children</DD></DL>
<P>The <CODE>flex-align</CODE> property aligns the contents of a flexbox child 
with the contents of other flexbox children in the same flexbox.  It has 
slightly different effects depending on the writing-mode of the flexbox 
child.</P>
<P>If the flexbox child has a vertical writing-mode (in a horizontal flexbox, 
remember - the same applies to a horizontal writing-mode in a vertical flexbox), 
then <CODE>flex-align</CODE> has only a minor effect.  A value of 
<CODE>before</CODE>, <CODE>after</CODE>, <CODE>middle</CODE>, or 
<CODE>baseline</CODE> will make the flexbox child's height flex if it is auto; a 
value of <CODE>shrink</CODE> makes an auto height shrink-wrap.</P>
<P>If the flexbox child has a horizontal writing-mode, <CODE>flex-align</CODE> 
has its full effect.  Similar to the previous paragraph, a value of 
<CODE>before</CODE>, <CODE>after</CODE>, <CODE>middle</CODE>, or 
<CODE>baseline</CODE> will make an auto height flex to the full height of the 
flexbox, while a value of <CODE>shrink</CODE> will make an auto height 
shrink-wrap.  As well, <CODE>flex-align</CODE> will align the contents of the 
flexbox children with each other.  All the flexbox children with the same value 
for <CODE>flex-align</CODE> will be aligned together, independent of the 
alignment of any flexbox children with a different <CODE>flex-align</CODE> 
values:</P>
<UL>
  <LI><STRONG>before</STRONG> and <STRONG>shrink</STRONG>: All flexbox children 
  with a value of <CODE>before</CODE> or <CODE>shrink</CODE> for 
  <CODE>flex-align</CODE> will have the before-side of their contents aligned 
  together.  In English text, for example, this is the top of the content.</LI>
  <LI><STRONG>after</STRONG>: All flexbox children with a value of 
  <CODE>after</CODE> for <CODE>flex-align</CODE> will have the after-side of 
  their contents aligned together.</LI>
  <LI><STRONG>middle</STRONG>: All flexbox children with a value of 
  <CODE>middle</CODE> for <CODE>flex-align</CODE> will have the middle of their 
  contents (halfway between the before-edge and the after-edge of their 
  content).</LI>
  <LI><STRONG>baseline</STRONG>: All flexbox children with a value of 
  <CODE>baseline</CODE> for <CODE>flex-align</CODE> will have the baselines of 
  their contents aligned.</LI></UL>


<H2>Flex Assignment Algorithm (<span class="issue">new</span>)</H2>
<P class="issue">TODO: to be completed</P>


  <h2 id="inlinesAndBlocks">Relationship to Inlines and blocks</h2>

  <p>
   A box placed in a block is considered a block level element and will be positioned
   and sized according to the rules for CSS 2.1 (section 10.3 for widths). Specifically,
   the following equation applies for calculating the width:
  </p>
  <blockquote>
  <p>'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + scrollbar width (if any) = width of containing block
  </p>
  </blockquote>
  <p>All children of 'box' elements are block-level. If inline-level elements are nested
     inside boxes, they get wrapped in an anonymous block which then takes part in the
     box layout.

  </p><p>
     If the width of a child of a flexible box is computed as 'auto', then the used value
     is the shrink-to-fit width. This calculation is done similarly to how the width of
     a floating element is determined. Otherwise if the width has a computed value,
     then that value is used as the width.
  </p><p>

     In a horizontally oriented box, the flexibility is then applied which may increase
     or decrease the used width. In a vertically oriented box, the position and size
     of the child may be adjusted by the value of the container's
     <span class="property">'box-align'</span> property.
  </p><p>

     The <span class="property">'min-width'</span>, <span class="property">'min-height'</span>,
     <span class="property">'max-width'</span>, and <span class="property">'max-height'</span>
     CSS properties act the same on boxes as on blocks.
  </p><p>

     The height of a child of a flexible box is determined in the same manner as specified
     in the CSS specification. The used height may further be adjusted by the container's
     <span class="property">'box-align'</span> property in a horizontally
     oriented box, or the flexibility in a vertically oriented box.
  </p><p>

     Note that it is possible for a horizontally oriented box that the height of a
     flexible child containing an inline descendant will change when the flexibility is
     applied. Similarly, in a vertically oriented box, the height of a child may change
     based on the <span class="property">'box-align'</span> property of the
     box.

  </p>

  <p class="note">
    Note: more details are needed here, and the relationship with other CSS constructs is
    yet to be defined.
  </p>

  <!--<h2 id="inlinesAndBlocks">Initial Containing Blocks</h2>

  <p>
  A user agent that supports flexible boxes may have a viewport where the size is
  computed from the content contained within it. Even if the viewport size is not
  known, it may be constrained by other physical constraints, such as the size of the
  screen, which may be used as the size of the viewport instead.

  </p><p>
  When the size of the viewport is not known, the size of the initial containing block
  will not be known beforehand. In this situation, this size will be computed from
  the contents within the block. Both the width and height of the initial containing
  block are considered to be 0 when computing a value that depends on the size of the
  initial containing block. Specifically, this means that a percentage size of
  the initial containing block will be calculated as 0.

  </p><p>
  Once the document has been laid out, the size of the viewport can be determined from
  the content, and that size may later be used when the document needs to be reflowed.
  -->

  <hr title="Separator from footer">

  <h2 class="no-num" id="acknowledgments"><a name="acknowledgments">Acknowledgments</a></h2>

  <p>[This section will contain further acknowledgments.]</p>

  <p>Thanks for feedback from James Elmore and Shinichiro Hamaji.</p>

  <h2 class="no-num" id="references">References</h2>

  <h3 class="no-num" id="normative">Normative references</h3>
  <!--normative-->

  <h2 class="no-num" id="index">Index</h2>
  <!--index-->

  <h2 id="property" class="no-num">Property index</h2>
  <!--properties-->

  <!-- Keep this comment at the end of the file
    Local variables:
    mode: sgml
    sgml-declaration:"~/SGML/HTML4.decl"
    sgml-default-doctype-name:"html"
    sgml-minimize-attributes:t
    sgml-nofill-elements:("pre" "style" "br")
    sgml-live-element-indicator:t
    End:
    -->
</body></html>

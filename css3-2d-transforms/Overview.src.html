<!DOCTYPE html PUBLIC '-//W3C//DTD HTML 4.01//EN'
  'http://www.w3.org/TR/html4/strict.dtd'>

<html lang="en">
<head>
  <title>CSS 2D Transforms Module Level 3</title>
  <link rel="stylesheet" type="text/css" href="default.css">
  <style type="text/css">
    .rhs { white-space: pre-wrap; }
    code { font-size: inherit; }
    #box-shadow-samples td { background: white; color: black; }
  </style>
  <link rel="stylesheet" type="text/css"
  href="http://www.w3.org/StyleSheets/TR/W3C-WD.css">
</head>

<body>

<div class="head">
<!--logo-->

<h1>CSS 2D Transforms Module Level 3</h1>

<h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>
<dl>
  <dt>This version:
    <dd>
    <a href="[VERSION]">http://dev.w3.org/csswg/css3-2d-transforms/</a>
    <!--http://www.w3.org/TR/[YEAR]/WD-[SHORTNAME]-[CDATE]-->
  <dt>Latest version:
    <dd><a
      href="http://www.w3.org/TR/css3-2d-transforms">[LATEST]</a>
  <dt>Previous version:
    <dd><a href="http://www.w3.org/TR/2009/WD-css3-2d-transforms-20090320/">
      http://www.w3.org/TR/2009/WD-css3-2d-transforms-20090320/</a>
  <dt id="editors-list">Editors:
    <dd><a href="mailto:dino@apple.com">Dean Jackson</a> (<a
      href="http://www.apple.com/">Apple Inc</a>)
    <dd><a href="mailto:hyatt@apple.com">David Hyatt</a> (<a
      href="http://www.apple.com/">Apple Inc</a>)
    <dd><a href="mailto:cmarrin@apple.com">Chris Marrin</a> (<a
      href="http://www.apple.com/">Apple Inc</a>)
</dl>

<!--copyright-->

<hr title="Separator for header">
</div>

<h2 class="no-num no-toc" id="abstract">Abstract</h2>

<p>CSS 2D Transforms allows elements rendered by CSS to be transformed
  in two-dimensional space.

<h2 class="no-num no-toc" id="status">Status of this document</h2>
<!--status-->

<p>
  The <a href="ChangeLog">list of changes made to this specification</a> is
  available.
</p>

<h2 class="no-num no-toc" id="contents">Table of contents</h2>
<!--toc-->


<h2>Introduction</h2>

<p><em>This section is not normative.</em>


      <p>
        The CSS <a href="http://www.w3.org/TR/REC-CSS2/visuren.html">visual
        formatting model</a> describes a coordinate system within which each
        element is positioned. Positions and sizes in this coordinate space can
        be thought of as being expressed in pixels, starting in the upper left
        corner of the parent with positive values proceeding to the right and
        down.
      </p>
      <p>
        This coordinate space can be modified with the <span
        class="prop-name">'transform'</span> property. Using transform, elements
        can be translated, rotated and scaled in two dimensional space.
        The coordinate space
        behaves as described in the <a
        href="http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace">coordinate
        system transformations</a> section of the SVG 1.1 specification. This is
        a coordinate system with two axes: the X axis increases horizontally to
        the right; the Y axis increases vertically downwards.
      </p>
      <p>
        Specifying a value other than 'none' for the <span
        class="prop-name">'transform'</span> property establishes a new
        <em>local coordinate system</em> at the element that it is applied to.
        Transformations are cumulative. That is, elements establish their local
        coordinate system within the coordinate system of their parent. In this
        way, a <span class="prop-name">'transform'</span> property effectively
        accumulates all the <span class="prop-name">'transform'</span>
        properties of its ancestors. The accumulation of these transforms
        defines a <em>current transformation matrix (CTM)</em> for the element.
      </p>
      <p>
        The transform property does not affect the flow of the content
        surrounding the transformed element. However, the value of the overflow
        area takes into account transformed elements. This behavior is similar
        to what happens when elements are translated via relative positioning.
        Therefore, if the value of the <span class="prop-name">'overflow'</span>
        property is <span class="prop-value">'scroll'</span> or <span
        class="prop-value">'auto'</span>, scrollbars will appear as needed to
        see content that is transformed outside the visible area.
      </p>
      <p>
        Any value other than 'none' for the transform results in the creation of
        both a stacking context and a containing block. The object acts as a
        containing block for fixed positioned descendants.
      </p>
      <div class="todo">
        Need to go into more detail here about why fixed positioned objects
        should do this, i.e., that it's much harder to implement otherwise.
      </div>
      <div class="issue">
        There are two roles for transformations in layout: (1) transformations
        that adjust the position of the affected content without changing the
        normal layout of that content (much like relative positioning) and (2)
        transformation of the content prior to layout that affects the layout
        of that content. See <a
        href="http://lists.w3.org/Archives/Public/www-style/2007Oct/0209">http://lists.w3.org/Archives/Public/www-style/2007Oct/0209</a>
        for examples of both cases. The "transform" property (as defined in
        this document) is equally useful for both roles. This document is
        focused on satisfying the first role. There is, however, an
        architectural question that arises because there needs to be a way to
        distinguish which role an author of a stylesheet wants. The key
        question is which is the default behavior/role for the "transform"
        property and how is the other behavior/role indicated by a stylesheet
        author. If you have an opinion on this topic,
        please send feedback.
      </div>
      <div class="issue">
        What do fixed backgrounds do in transforms? They should probably ignore
        the transform completely, since - even transformed - the object should
        be acting as "porthole" through which the fixed background can be viewed
        in its original form.
      </div>
      <div class="issue">
        This property should also be applicable to SVG elements.
      </div>
      <div class="issue">
        We also need to specify that SVG transforms *do* combine with this
        transform, e.g., if a &lt;foreignObject&gt; is inside transformed SVG
        and then defines a transform of its own. This means we may potentially
        have to examine the current SVG transform and combine with it to set the
        correct transform.
      </div><!-- ======================================================================================================= -->
      <h2 id="transform-property">
        The <span class="prop-name">'transform'</span> Property
      </h2>
      <p>
        A two-dimensional transformation is applied to an element through the <span
        class="prop-name">'transform'</span> property. This property contains a
        list of <a href="#transform-functions">transform functions</a>. The
        final transformation value for an element is obtained by performing a
        matrix concatenation of each entry in the list. The set of transform
        functions is similar to those allowed by SVG.
      </p>
      <table class="propdef">
        <tbody>
          <tr>
            <td>
              <em>Name:</em>
            </td>
            <td>
              <dfn id="effects">transform</dfn>
            </td>
          </tr>
          <tr>
            <td>
              <em>Value:</em>
            </td>
            <td>
              none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]*
            </td>
          </tr>
          <tr>
            <td>
              <em>Initial:</em>
            </td>
            <td>
              none
            </td>
          </tr>
          <tr>
            <td>
              <em>Applies&nbsp;to:</em>
            </td>
            <td>
              block-level and inline-level elements
            </td>
          </tr>
          <tr>
            <td>
              <em>Inherited:</em>
            </td>
            <td>
              no
            </td>
          </tr>
          <tr>
            <td>
              <em>Percentages:</em>
            </td>
            <td>
              refer to the size of the element's border box
            </td>
          </tr>
          <tr>
            <td>
              <em>Media:</em>
            </td>
            <td>
              visual
            </td>
          </tr>
          <tr>
            <td>
              <em>Computed value:</em>
            </td>
            <td>
              Same as specified value.
            </td>
          </tr>
        </tbody>
      </table><!-- ======================================================================================================= -->
      <h2 id="transform-origin-property">
        The <span class="prop-name">'transform-origin'</span> Property
      </h2>
      <p>
        The <span class="prop-name">'transform-origin'</span> property
        establishes the origin of transformation for an element. This property
        is applied by first translating the element by the negated value of the
        property, then applying the element's transform, then translating by the
        property value. This effectively moves the desired transformation origin
        of the element to (0,0) in the local coordinate system, then applies
        the element's transform, then moves the element back to its original
        position.
      </p>
      
      <p>If only one value is specified, the second value is assumed to be
      'center'. If two values are given and at least one value is not a keyword,
      then the first value represents the horizontal position (or offset) and
      the second represents the vertical position (or
      offset). <var>&lt;percentage&gt;</var> and <var>&lt;length&gt;</var>
      values here represent an offset of the transform origin from the top left corner
      of the element's border box.
    </p>

      <p>If three or four values are given, then
      each <var>&lt;percentage&gt;</var> or<var>&lt;length&gt;</var>
      represents an offset and must be preceded by a keyword,
      which specifies from which edge the offset is given. For example,
      ''transform-origin: bottom 10px right 20px'' represents a
      ''10px'' vertical offset up from the bottom edge and a
      ''20px'' horizontal offset leftward from the right edge. If
      three values are given, the missing offset is assumed to be zero.
      </p>

      <p>Positive values represent an offset <em>inward</em> from the edge of
      the border box. Negative values represent an offset
      <em>outward</em> from the edge of the border box.
    </p>

      <table class="propdef">
        <tbody>
          <tr>
            <td>
              <em>Name:</em>
            </td>
            <td>
              <dfn id="transform-origin">transform-origin</dfn>
            </td>
          </tr>
          <tr>
            <td>
              <em>Value:</em>
            </td>
            <td>
    [ top | bottom ] |<br>
    [ &lt;percentage> | &lt;length&gt; | left | center | right ] [ &lt;percentage> | &lt;length&gt; | top | center | bottom ]? |<br>
    [ center | [ left | right ] [ &lt;percentage> | &lt;length&gt; ]? ] &amp;&amp; [ center | [ top | bottom ] [ &lt;percentage> | &lt;length&gt; ]? ]<br>
            </td>
          </tr>
          <tr>
            <td>
              <em>Initial:</em>
            </td>
            <td>
              50% 50%
            </td>
          </tr>
          <tr>
            <td>
              <em>Applies&nbsp;to:</em>
            </td>
            <td>
              block-level and inline-level elements
            </td>
          </tr>
          <tr>
            <td>
              <em>Inherited:</em>
            </td>
            <td>
              no
            </td>
          </tr>
          <tr>
            <td>
              <em>Percentages:</em>
            </td>
            <td>
              refer to the size of the element's border sbox
            </td>
          </tr>
          <tr>
            <td>
              <em>Media:</em>
            </td>
            <td>
              visual
            </td>
          </tr>
          <tr>
            <td>
              <em>Computed value:</em>
            </td>
            <td>
              For &lt;length&gt; the absolute value, otherwise a percentage
            </td>
          </tr>
        </tbody>
      </table>

      <!-- ======================================================================================================= -->

      <h2 id="transform-functions">
        The Transformation Functions
      </h2>
      <p>
        The value of the <span class="prop-name">transform</span> property is a
        list of &lt;transform-functions&gt; applied in the order provided. The
        individual transform functions are separated by whitespace. The
        set of allowed transform functions is given below. In this list the
        type &lt;translation-value&gt; is defined as a &lt;length&gt; or
        &lt;percentage&gt; value, and the &lt;angle&gt; type is defined by <a
        href="http://www.w3.org/TR/css3-values/">CSS Values and Units.</a>
      </p>
      <dl>
        <dt>
          <span class="prop-value">matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</span>
        </dt>
        <dd>
          specifies a 2D transformation in the form of a <a href="http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined">transformation matrix</a> of six values. <span class="prop-value">matrix(a,b,c,d,e,f)</span> is equivalent to applying the transformation matrix <strong>[a b c d e f]</strong>.
        </dd>
        <dt>
          <span class="prop-value">translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined">2D translation</a> by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <em>&lt;ty&gt;</em> is not provided, ty has zero as a value.
        </dd>
        <dt>
          <span class="prop-value">translateX(&lt;translation-value&gt;)</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined">translation</a> by the given amount in the X direction.
        </dd>
        <dt>
          <span class="prop-value">translateY(&lt;translation-value&gt;)</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#TranslationDefined">translation</a> by the given amount in the Y direction.
        </dd>
        <dt>
          <span class="prop-value">scale(&lt;number&gt;[, &lt;number&gt;])</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#ScalingDefined">2D scale</a> operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it is takes a value equal to the first.
        </dd>
        <dt>
          <span class="prop-value">scaleX(&lt;number&gt;)</span>
        </dt>
        <dd>
          specifies a scale operation using the [sx,1] scaling vector, where sx is given as the parameter.
        </dd>
        <dt>
          <span class="prop-value">scaleY(&lt;number&gt;)</span>
        </dt>
        <dd>
          specifies a scale operation using the [1,sy] scaling vector, where sy is given as the parameter.
        </dd>
        <dt>
          <span class="prop-value">rotate(&lt;angle&gt;)</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#RotationDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as defined by the <em>transform-origin</em> property.
        </dd>
        <dt>
          <span class="prop-value">skewX(&lt;angle&gt;)</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined">skew transformation along the X axis</a> by the given angle.
        </dd>
        <dt>
          <span class="prop-value">skewY(&lt;angle&gt;)</span>
        </dt>
        <dd>
          specifies a <a href="http://www.w3.org/TR/SVG/coords.html#SkewYDefined">skew transformation along the Y axis</a> by the given angle.
        </dd>
        <dt>
          <span class="prop-value">skew(&lt;angle&gt; [, &lt;angle&gt;])</span>
        </dt>
        <dd>
          specifies a <a
          href="http://www.w3.org/TR/SVG/coords.html#SkewXDefined">skew
          transformation along the X and Y axes</a>. The first angle parameter
          specifies the skew on the X axis. The second angle parameter specifies
          the skew on the Y axis. If the second parameter is not given then a
          value of 0 is used for the Y angle (ie. no skew on the Y axis).
        </dd>
      </dl>
      <h2 id="transform-values">
        Transform Values and Lists
      </h2>
      <p>
        The &lt;translation-value&gt; values are defined as [&lt;percentage&gt; | &lt;length&gt;]. All other value types are described <a href="http://www.w3.org/TR/REC-CSS2/syndata.html#values">as CSS types</a>. If a list of transforms is provided, then the net effect is as if each transform had been specified separately in the order provided. For example,
      </p>
      <pre>
  &lt;div style="transform:translate(-10px,-20px) scale(2) rotate(45deg) translate(5px,10px)"/&gt;
  </pre>
      <p>
        is functionally equivalent to:
      </p>
      <pre>
  &lt;div style="transform:translate(-10px,-20px)"&gt;
    &lt;div style="transform:scale(2)"&gt;
      &lt;div style="transform:rotate(45deg)"&gt;
        &lt;div style="transform:translate(5px,10px)"&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  </pre>
      <div class="example">
        <pre>
  div {
      transform: translate(100px, 100px);
  }
  </pre>Move the element by 100 pixels in both the X and Y directions.
        <div class="figure">
          <img src="transform1.png" alt="The 100px translation in X and Y">
        </div>
      </div>
      <div class="example">
        <pre>
  div {
      height: 100px; width: 100px;
      transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
  }
  </pre>Move the element by 80 pixels in both the X and Y directions, then scale the element by 150%, then rotate it 45 degrees clockwise about the Z axis. Note that the scale and rotate operate about the center of the element, since the element has the default transform-origin of 50% 50%.
        <div class="figure">
          <img src="compound_transform.png" alt="The transform specified above">
        </div>
      </div>
  <!-- ======================================================================================================= -->

      <h2 id="animation">
        Transitions and animations between transform values
      </h2>

      <p>
        When animating or transitioning the value of a transform property
        the rules described below are applied. The 'from' transform is
        the transform at the start of the transition or current keyframe. The
        'end' transform is the transform at the end of the transition or
        current keyframe.
      </p>

      <ul>
        <li>
          If the 'from' and 'to' transforms are both single functions
          of the same type:
          <ul>
            <li>
              For translate, translateX, translateY, scale,
              scaleX, scaleY, rotate, skew, skewX and skewY functions:
                <ul>
                  <li>
                    the individual components of the function are
                    interpolated numerically.
                  </li>
                </ul>
            </li>
            <li>
              For matrix:
                <ul>
                  <li>
                    the matrix is
                    decomposed using <a
                    href="http://tog.acm.org/GraphicsGems/gemsii/unmatrix.c">the
                    method described by unmatrix</a> into separate translation,
                    scale, rotation and skew matrices, then each
                    decomposed matrix is interpolated numerically, and finally
                    combined in order to produce a resulting 3x2 matrix.
                  </li>
                </ul>
            </li>
          </ul>
        </li>
        <li>
          If both the 'from' and 'to' transforms are "none":
          <ul>
            <li>
              There is no interpolation necessary
            </li>
          </ul>
        </li>
        <li>
          If one of the 'from' or 'to' transforms is "none":
          <ul>
            <li>
              The 'none' is replaced by an equivalent identity function list for
              the corresponding transform function list.
              <p>
                For example, if the 'from' transform is "scale(2)" and the 'to'
                transform is "none" then the value "scale(1)" will be used as the
                'to' value, and animation will proceed using the rule above.
                Similarly, if the 'from' transform is "none" and the 'to' transform
                is "scale(2) rotate(50deg)" then the animation will execute as
                if the 'from' value is "scale(1) rotate(0)".
              </p>
              <p>
                The identity functions are translate(0), 
                translateX(0), translateY(0), scale(1),
                scaleX(1), scaleY(1), rotate(0),
                rotateX(0), rotateY(0), skewX(0), skewY(0), skew(0, 0)
                and matrix(1, 0, 0, 1, 0, 0).
              </p>
            </li>
          </ul>
        </li>
        <li>
          If both the 'from' and 'to' transforms have the same number of
          transform functions and corresponding functions in each transform
          list are of the same type:
          <ul>
            <li>
              Each transform function is animated with its corresponding
              destination function in isolation using the rules described above.
              The individual values are then applied as a list to produce
              resulting transform value.
            </li>
          </ul>
        </li>
        <li>
          Otherwise:
          <ul>
            <li>
              The transform function lists are each converted into the
              equivalent matrix value and animation proceeds using the rule
              for a single function above.
            </li>
          </ul>
        </li>
      </ul>
      
      <p>
        In some cases, an animation might cause a transformation matrix to
        be singular or non-invertible. For example, an animation in which
        scale moves from 1 to -1. At the time when the matrix is in such 
        a state, the transformed element is not rendered.
      </p>

      <h2 id="matrix-decomposition">
        Matrix decomposition for animation
      </h2>

      <p>
        When interpolating between 2 matrices, each is decomposed into the
        corresponding translation, rotation, scale, skew, and perspective
        values. Not all matrices can be accurately described by these values.
        Those that can't are decomposed into the most accurate representation
        possible, using the technique below. This technique is taken from The
        "unmatrix" method in "Graphics Gems II, edited by Jim Arvo". The
        pseudocode below works on a 4x4 homogeneous matrix. A 3x2 2D matrix is
        therefore first converted to 4x4 homogeneous form.
      </p>

      <pre>
  Input: matrix       ; a 4x4 matrix
  Output: translation ; a 3 component vector
          rotation    ; Euler angles, represented as a 3 component vector
          scale       ; a 3 component vector
          skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
          perspective ; a 4 component vector
  Returns false if the matrix cannot be decomposed, true if it can

    Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix):
      float  determinant(matrix)          returns the 4x4 determinant of the matrix
      matrix inverse(matrix)              returns the inverse of the passed matrix
      matrix transpose(matrix)            returns the transpose of the passed matrix
      point  multVecMatrix(point, matrix) multiplies the passed point by the passed matrix 
                                          and returns the transformed point
      float  length(point)                returns the length of the passed vector
      point  normalize(point)             normalizes the length of the passed point to 1
      float  dot(point, point)            returns the dot product of the passed points
      float  cos(float)                   returns the cosine of the passed angle in radians
      float  asin(float)                  returns the arcsine in radians of the passed value
      float  atan2(float y, float x)      returns the principal value of the arc tangent of 
                                          y/x, using the signs of both arguments to determine 
                                          the quadrant of the return value

    Decomposition also makes use of the following function:
      point combine(point a, point b, float ascl, float bscl)
          result[0] = (ascl * a[0]) + (bscl * b[0])
          result[1] = (ascl * a[1]) + (bscl * b[1])
          result[2] = (ascl * a[2]) + (bscl * b[2])
          return result


    // Normalize the matrix.
    if (matrix[3][3] == 0)
        return false

    for (i = 0; i &lt; 4; i++)
        for (j = 0; j &lt; 4; j++)
            matrix[i][j] /= matrix[3][3]

    // perspectiveMatrix is used to solve for perspective, but it also provides
    // an easy way to test for singularity of the upper 3x3 component.
    perspectiveMatrix = matrix

    for (i = 0; i &lt; 3; i++)
        perspectiveMatrix[i][3] = 0

    perspectiveMatrix[3][3] = 1

    if (determinant(perspectiveMatrix) == 0)
        return false

    // First, isolate perspective.
    if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
        // rightHandSide is the right hand side of the equation.
        rightHandSide[0] = matrix[0][3];
        rightHandSide[1] = matrix[1][3];
        rightHandSide[2] = matrix[2][3];
        rightHandSide[3] = matrix[3][3];

        // Solve the equation by inverting perspectiveMatrix and multiplying
        // rightHandSide by the inverse.
        inversePerspectiveMatrix = inverse(perspectiveMatrix)
        transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
        perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)

         // Clear the perspective partition
        matrix[0][3] = matrix[1][3] = matrix[2][3] = 0
        matrix[3][3] = 1
    else
        // No perspective.
        perspective[0] = perspective[1] = perspective[2] = 0
        perspective[3] = 1

    // Next take care of translation
    translate[0] = matrix[3][0]
    matrix[3][0] = 0
    translate[1] = matrix[3][1]
    matrix[3][1] = 0
    translate[2] = matrix[3][2]
    matrix[3][2] = 0

    // Now get scale and shear. &#x27;row&#x27; is a 3 element array of 3 component vectors
    for (i = 0; i &lt; 3; i++)
        row[i][0] = matrix[i][0]
        row[i][1] = matrix[i][1]
        row[i][2] = matrix[i][2]

    // Compute X scale factor and normalize first row.
    scale[0] = length(row[0])
    row[0] = normalize(row[0])

    // Compute XY shear factor and make 2nd row orthogonal to 1st.
    skew[0] = dot(row[0], row[1])
    row[1] = combine(row[1], row[0], 1.0, -skew[0])

    // Now, compute Y scale and normalize 2nd row.
    scale[1] = length(row[1])
    row[1] = normalize(row[1])
    skew[0] /= scale[1];

    // Compute XZ and YZ shears, orthogonalize 3rd row
    skew[1] = dot(row[0], row[2])
    row[2] = combine(row[2], row[0], 1.0, -skew[1])
    skew[2] = dot(row[1], row[2])
    row[2] = combine(row[2], row[1], 1.0, -skew[2])

    // Next, get Z scale and normalize 3rd row.
    scale[2] = length(row[2])
    row[2] = normalize(row[2])
    skew[1] /= scale[2]
    skew[2] /= scale[2]

    // At this point, the matrix (in rows) is orthonormal.
    // Check for a coordinate system flip.  If the determinant
    // is -1, then negate the matrix and the scaling factors.
    pdum3 = cross(row[1], row[2])
    if (dot(row[0], pdum3) &lt; 0)
        for (i = 0; i &lt; 3; i++) {
            scale[0] *= -1;
            row[i][0] *= -1
            row[i][1] *= -1
            row[i][2] *= -1

    // Now, get the rotations ou
    rotate[1] = asin(-row[0][2]);
    if (cos(rotate[1]) != 0)
       rotate[0] = atan2(row[1][2], row[2][2]);
       rotate[2] = atan2(row[0][1], row[0][0]);
    else
       rotate[0] = atan2(-row[2][0], row[1][1]);
       rotate[2] = 0;

    return true;
    </pre>

    <p>
      Each component of each returned value is linearly interpolated with the
      corresponding component of the other matrix. The resulting components are
      then recomposed into a final matrix as though combining the following
      transform functions:
    </p>

      <pre>
        matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, perspective[0], perspective[1], perspective[2], perspective[3])
        translate3d(translation[0], translation[1], translation[2])
        rotateX(rotation[0]) rotateY(rotation[1]) rotateZ(rotation[2])
        matrix3d(1,0,0,0, 0,1,0,0, 0,skew[2],1,0, 0,0,0,1)
        matrix3d(1,0,0,0, 0,1,0,0, skew[1],0,1,0, 0,0,0,1)
        matrix3d(1,0,0,0, skew[0],1,0,0, 0,0,1,0, 0,0,0,1)
        scale3d(scale[0], scale[1], scale[2])
      </pre>


      <h2 id="dom-interfaces">
        DOM Interfaces
      </h2>
      <p>
        This section describes the interfaces and functionality added to the DOM
        to support runtime access to the functionality described above.
      </p>

      <h3 id="cssmatrix-interface">
        CSSMatrix
      </h3>

      <dl>
        <dt>
          <b>Interface <i><a id="DOM-CSSMatrix" name='DOM-CSSMatrix'>CSSMatrix</a></i></b>
        </dt>
        <dd>
          <p>
            The <code>CSSMatrix</code> interface represents a 4x4 homogeneous matrix.
          </p>
          <dl>

            <dt>
              <b>IDL Definition</b>
            </dt>
            <dd>
              <div class='idl-code'>
                <pre>
  interface CSSMatrix {
      attribute float a;
      attribute float b;
      attribute float c;
      attribute float d;
      attribute float e;
      attribute float f;

      void        setMatrixValue(in DOMString string) raises(DOMException);
      CSSMatrix   multiply(in CSSMatrix secondMatrix);
      CSSMatrix   multiplyLeft(in CSSMatrix secondMatrix);
      CSSMatrix   inverse() raises(DOMException);
      CSSMatrix   translate(in float x, in float y);
      CSSMatrix   scale(in float scaleX, in float scaleY);
      CSSMatrix   skew(in float angleX, in float angleY);
      CSSMatrix   rotate(in float angle);
  };</pre>
              </div><br>
            </dd> <!-- IDL -->

            <dt>
              <b>Attributes</b>
            </dt>
            <dd>
              <dl>
                <dt>
                  <code class='attribute-name'><a id="DOM-CSSMatrix-matrix" name='DOM-CSSMatrix-matrix'>a-f</a></code> of type <code>float</code>
                </dt>
                <dd>
                  Each of these attributes represents one of the values in the 3x2 matrix.<br>
                </dd>
              </dl>
            </dd> <!-- Attributes -->

            <dt>
              <b>Methods</b>
            </dt>
            <dd>
              <dl>

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-setMatrixValue" name='DOM-CSSMatrix-setMatrixValue'>setMatrixValue</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>setMatrixValue</code> method replaces the existing matrix with one computed from parsing the passed string
                    as though it had been assigned to the transform property in a CSS style rule.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>string</code> of type <code>DOMString</code>
                          </dt>
                          <dd>
                            The string to parse.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>No Return Value</b>
                    </div>
                    <div>
                      <b>Exceptions</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>DOMException SYNTAX_ERR</code>
                          </dt>
                          <dd>
                            Thrown when the provided string can not be
                            parsed into a CSSMatrix.
                          </dd>
                        </dl>
                      </div>
                    </div>
                  </div>
                </dd> <!-- setMatrixValue -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-multiply" name='DOM-CSSMatrix-multiply'>multiply</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>multiply</code> method returns a new CSSMatrix which is the result of this matrix multiplied by the passed matrix, with the passed matrix to the right. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>secondMatrix</code> of type <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The matrix to multiply.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div>
                </dd> <!-- multiply() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-multiplyLeft" name='DOM-CSSMatrix-multiplyLeft'>multiplyLeft</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>multiplyLeft</code> method returns a new CSSMatrix which is the result of this matrix multiplied by the passed matrix, with the passed matrix to the left. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>secondMatrix</code> of type <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The matrix to multiply.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div>
                </dd> <!-- multiplyLeft() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-inverse" name='DOM-CSSMatrix-inverse'>inverse</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>inverse</code> method returns a new matrix which is the inverse of this matrix. This matrix is not modified.
                    <div class='parameters'>
                      <b>No Parameters</b>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The inverted matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>Exceptions</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>DOMException NOT_SUPPORTED_ERR</code>
                          </dt>
                          <dd>
                            Thrown when the CSSMatrix can not be
                            inverted.
                          </dd>
                        </dl>
                      </div>
                    </div>
                  </div><!-- ======================================================================================================= -->
                </dd> <!-- inverse() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-translate" name='DOM-CSSMatrix-translate'>translate</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>translate</code> method returns a new matrix which is this matrix post multiplied by a translation matrix containing the passed values. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>x</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The X component of the translation value.<br>
                          </dd>
                          <dt>
                            <code class='parameter-name'>y</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The Y component of the translation value.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div><!-- ======================================================================================================= -->
                </dd> <!-- translate() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-scale" name='DOM-CSSMatrix-scale'>scale</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>scale</code> method returns a new matrix which is this matrix post multiplied by a scale matrix containing the passed values. If the y component is undefined, the x component value is used in its place. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>scaleX</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The X component of the scale value.<br>
                          </dd>
                          <dt>
                            <code class='parameter-name'>scaleY</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The (optional) Y component of the scale value.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div><!-- ======================================================================================================= -->
                </dd> <!-- scale() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-rotate" name='DOM-CSSMatrix-rotate'>rotate</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>rotate</code> method returns a new matrix which is this matrix post multiplied by a rotation matrix. The rotation value is in degrees. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>angle</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The angle of rotation.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div>
                  <!-- ======================================================================================================= -->
                </dd> <!-- rotate() -->

                <!-- ===================================================== -->
                <dt>
                  <code class='method-name'><a id="DOM-CSSMatrix-skew" name='DOM-CSSMatrix-skew'>skew</a></code>
                </dt>
                <dd>
                  <div class='method'>
                    The <code>skew</code> method returns a new matrix which is this matrix post multiplied by a skew matrix. The rotation value is in degrees. This matrix is not modified.
                    <div class='parameters'>
                      <b>Parameters</b>
                      <div class='paramtable'>
                        <dl>
                          <dt>
                            <code class='parameter-name'>angleX</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The angle of skew along the X axis.<br>
                          </dd>
                          <dt>
                            <code class='parameter-name'>angleY</code> of type <code>float</code>
                          </dt>
                          <dd>
                            The angle of skew along the Y axis.<br>
                          </dd>
                        </dl>
                      </div>
                    </div><!-- parameters -->
                    <div class='return-value'>
                      <b>Return Value</b>
                      <div class='returnvalue'>
                        <dl>
                          <dt>
                            <code>CSSMatrix</code>
                          </dt>
                          <dd>
                            The result matrix.<br>
                          </dd>
                        </dl>
                      </div>
                    </div>
                    <div>
                      <b>No Exceptions</b>
                    </div>
                  </div>
                  <!-- ======================================================================================================= -->
                </dd> <!-- skew() -->

              </dl><!-- methods -->
            </dd>

          </dl>
        </dd> <!-- Interface CSSMatrix -->
      </dl>

      <p>
        In addition to the interface listed above, the <code>getComputedStyle</code> method of the <code>Window</code>
        object has been updated. The <code>transform</code> property of the style object returned by
        <code>getComputedStyle</code> contains a DOMString of the form "matrix(a, b, c, d, e, f)"
        representing the 3x2 matrix that is the result of applying the individual functions listed in the
        <code>transform</code> property.
      </p>

<h2>References</h2>

<h3 class="no-num">Normative references</h3>
<!--normative-->

<h3 class="no-num">Other references</h3>
<!--informative-->



<h2 class="no-num">Property index</h2>
<!-- properties -->



<h2 class="no-num" id="index">Index</h2>
<!--index-->

</body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
End:
-->
